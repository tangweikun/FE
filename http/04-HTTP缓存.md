[HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)

[HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)

[HTTP 缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)

[彻底弄懂 Http 缓存机制](https://zhuanlan.zhihu.com/p/24467558)

[Web 缓存机制](http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/)

缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是 304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

### 强缓存

#### `Expires`(HTTP1.0)

`Expires` 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires 是 HTTP1.0 的产物，故现在大多数使用 `Cache-Control` 替代

缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。

#### `Pragma`(HTTP1.0)

HTTP1.0 时的遗留字段，当值为 `no-cache` 时强制验证缓存，`Pragma` 禁用缓存，如果又给 `Expires` 定义一个还未到期的时间，那么 Pragma 字段的优先级会更高。服务端响应添加`'Pragma': 'no-cache'`，浏览器表现行为和刷新(F5)类似

#### Cache-Control(HTTP1.1)

有很多属性，不同的属性代表的意义也不同

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在 t 秒后失效
- no-cache：需要使用协商缓存来验证缓存数据
- no-store：所有内容都不会缓存

### 协商缓存

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回 304 状态码，浏览器拿到此状态码就可以直接使用缓存数据了

#### Last-Modified

服务器在响应请求时，会告诉浏览器资源的最后修改时间

#### if-Modified-Since

浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 `if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可

- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
- 如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified

#### if-Unmodified-Since

从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差

- 如果没有被修改：则开始继续传送文件，服务器返回: 200 OK
- 如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)

这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 `Last-Modified` 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 `Etag`

#### Etag

服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

#### If-Match

条件请求，携带上一次请求中资源的 `ETag`，服务器根据这个字段判断文件是否有新的修改

#### If-None-Match

再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 `If-None-Match` 则与被请求资源的唯一标识进行对比

- 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200
- 相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304

但是实际应用中由于 `Etag` 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 `Etag` 了
